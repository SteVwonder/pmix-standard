%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Chapter: Introduction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}
\label{chap:intro}

The \ac{PMI} has been used for quite some time as a means of exchanging wireup information needed for inter-process communication.
Two versions (PMI-1 and PMI-2) have been released as part of the MPICH effort, with PMI-2 demonstrating better scaling properties than its PMI-1 predecessor. However, two significant challenges face the \ac{HPC} community as it continues to move towards machines capable of exaflop and higher performance levels:

\begin{itemize}
\item the physical scale of the machines, and the corresponding number of total processes they support, is expected to reach levels approaching  1 million processes executing across 100 thousand nodes. Prior methods for initiating applications relied on exchanging communication endpoint information between the processes, either directly or in some form of hierarchical collective operation. Regardless of the specific mechanism employed, the exchange across such large applications would consume considerable time, with estimates running in excess of 5-10 minutes; and
\item whether it be hybrid applications that combine OpenMP threading operations with MPI, or application-steered workflow computations, the HPC community is experiencing an unprecedented wave of new approaches for computing at exascale levels. One common thread across the proposed methods is an increasing need for orchestration between the application and the \ac{SMS} comprising the scheduler (a.k.a. the \ac{WLM}), the \ac{RM}, global file system, fabric, and other subsystems. The lack of available support for application-to-SMS integration has forced researchers to develop "virtual" environments that hide the SMS behind a customized abstraction layer, but this results in considerable duplication of effort and a lack of portability.
\end{itemize}

\ac{PMIx} represents an attempt to resolve these questions by providing an extended version of the \ac{PMI} definitions specifically designed to support clusters up to exascale and larger sizes.
The overall objective of the project is not to branch the existing definitions -- in fact, PMIx fully supports both of the existing PMI-1 and PMI-2 APIs -- but rather to:

\begin{compactalphaenum}
\item augment those APIs to eliminate some current restrictions that impact scalability,
\item extend the breadth of the \ac{PMI} definitions to providing an abstraction layer for \ac{SMS} interactions,
\item establish a standards-like body for maintaining the definitions, and
\item provide a reference implementation of the PMIx standard that demonstrates the desired level of scalability and features.
\end{compactalphaenum}

Complete information about the \ac{PMIx} standard and affiliated projects can be found at the \ac{PMIx} web site: \url{https://pmix.org}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Charter}
\label{chap:intro:charter}

The charter of the PMIx community is to:
\begin{itemize}
\item Define a set of agnostic APIs (not affiliated with any specific programming model or code base) to support interactions between application processes and the \ac{SMS}.
\item Develop an open source (non-copy-left licensed) standalone ``reference'' library to facilitate adoption of the \ac{PMIx} standard.
\item Retain transparent backward compatibility with the existing PMI-1 and PMI-2 definitions, any future \ac{PMI} releases, and across all \ac{PMIx} versions.
\item Support the ``Instant On'' initiative for rapid startup of applications at exascale and beyond.
\item Work with the \ac{HPC} community to define and implement new APIs that support evolving programming model requirements for application interactions with the \ac{SMS}.
\end{itemize}

Participation in the \ac{PMIx} community is open to anyone, and not restricted to only code contributors to the reference implementation.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{PMIx Standard Overview}
\label{chap:intro:std_overview}

\ldots

%%%%%%%%%%%
\subsection{Who should use the standard?}

\ldots

%%%%%%%%%%%
\subsection{What is defined in the standard?}

\ldots

%%%%%%%%%%%
\subsection{What is \emph{not} defined in the standard?}

The \ac{PMIx} Standard does not include anything, either stated or implied, regarding implementation.
It instead focuses exclusively on defining APIs and associated attribute key strings, and describing the expected behavior of those entities.
How that behavior is realized is entirely at the discretion of the implementer.

As previously noted, system environments and \ac{PMIx} library implementers are free to return ``not supported'' for any request. Thus, users should design their applications accordingly.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{PMIx Architecture Overview}
\label{chap:intro:arch_overview}

This section presents a brief overview the \ac{PMIx} Architecture~\cite{2017-Castain-EuroMPI}.

\ldots

%%%%%%%%%%%
\subsection{The PMIx Reference Implementation}

Note that the definition of the \ac{PMIx} Standard is not contingent upon use of the \ac{PMIx} Reference Implementation.
Any implementation that supports the defined APIs is a \ac{PMIx} Standard compliant implementation, and some environments have chosen to pursue their own custom implementation.
The \ac{PMIx} Reference Implementation is provided solely for the following purposes:
\begin{itemize}
\item Validation of the standard.\\
No proposed change and/or extension to the \ac{PMIx} standard is accepted without an accompanying prototype implementation in the \ac{PMIx} Reference Implementation.
This ensures that the proposal has undergone at least some minimal level of scrutiny and testing before being considered.
\item Ease of adoption.\\
The \ac{PMIx} Reference Implementation is designed to be particularly easy for resource managers (and the \ac{SMS} in general) to adopt, thus facilitating a rapid uptake into that community for application portability.
Both client and server \ac{PMIx} libraries are included, along with examples of client usage and server-side integration.
A list of supported environments and versions is provided on the \ac{PMIx} web site \url{www.pmix.org}
\end{itemize}

The \ac{PMIx} Reference Implementation targets support for the Linux operating system.
A reasonable effort is made to support all major, modern Linux distributions; however, validation is limited to the most recent 2-3 releases of RedHat Enterprise Linux (RHEL), Fedora, CentOS, and SUSE Linux Enterprise Server (SLES).
In addition, development support is maintained for Mac OSX.
Production support for vendor-specific operating systems is included as provided by the vendor.

%%%%%%%%%%%
\subsection{The PMIx Reference Server}

\ldots


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Organization of this document}

The remainder of this document is structured as follows:

\begin{itemize}
\item Introduction and Overview in \chapterref{chap:intro}
\item Terms and Conventions in \chapterref{chap:terms}
\item Data Structures and Types in \chapterref{chap:struct}
\item \ac{PMIx} Initialization and Finalization in \chapterref{chap:api_init}
\item Key/Value Management in \chapterref{chap:api_kv_mgmt}
\item Process Management in \chapterref{chap:api_proc_mgmt}
\item Job Management in \chapterref{chap:api_job_mgmt}
\item Event Notification in \chapterref{chap:api_event}
\item Data Packing and Unpacking in \chapterref{chap:api_data_mgmt}
\item \ac{PMIx} Server Specific Interfaces in \chapterref{chap:api_server}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
