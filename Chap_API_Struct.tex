%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Chapter: Data Structures
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Data Structures and Types}
\label{chap:struct}

\ldots

%%%%%%%%%%%
\section{Constants}
\declarestruct{pmix_rank_t}

The constant defined in this section may be used before calling any library initialization routine.

\begin{constantdesc}
%
\declareconstitem{PMIX_MAX_NSLEN} (integer)
Maximum namespace string length
%
\declareconstitem{PMIX_MAX_KEYLEN} (integer)
Maximum key string length
%
\end{constantdesc}

The \refstruct{pmix_rank_t} structure is an integer type for rank values.

The following constants can be used to set the \refstruct{pmix_rank_t}.

\begin{constantdesc}
%
\declareconstitem{PMIX_RANK_UNDEF}
Define a value for requests for job-level data where the info itself is not associated with any specific rank, or when a request involves a rank that is not known.
For example, when someone requests info thru one of the legacy interfaces where the rank is typically encoded into the key itself since there is no rank parameter in the API itself.
%
\declareconstitem{PMIX_RANK_WILDCARD}
Define a value to indicate that the user wants the data for the given key from every rank that posted that key.
%
\declareconstitem{PMIX_RANK_LOCAL_NODE}
Special rank value used to define groups of ranks for use in collectives.
All ranks on a local node.
%
\end{constantdesc}


%%%%%%%%%%%
\subsection{Reserved attributes}
\label{api:struct:attributes}

Define a set of ``standard'' PMIx attributes that can be queried.
Implementations (and users) are free to extend as desired, so the get functions need to be capable of handling the ``not found'' condition.
Note that these are attributes of the system and the job as opposed to values the application (or underlying \ac{MPI} library) might choose to expose - i.e., they are values provided by the resource manager as opposed to the application.
Thus, these keys are \textbf{RESERVED}.

\declareAttribute{PMIX_ATTR_UNDEF}{NULL}{NULL}{
Constant representing an undefined attribute.
}

%%%%%%%%%%%
\subsubsection{Initialization attributes}
\label{api:struct:attributes:init}

\ldots

%
\declareAttribute{PMIX_EVENT_BASE}{"pmix.evbase"}{struct event_base *}{
Pointer to libevent event_base to use in place of the internal progress thread.
}

%
\declareAttribute{PMIX_SERVER_TOOL_SUPPORT}{"pmix.srvr.tool"}{bool}{
The host RM wants to declare itself as willing to accept tool connection requests.
}

%
\declareAttribute{PMIX_SERVER_REMOTE_CONNECTIONS}{"pmix.srvr.remote"}{bool}{
Allow connections from remote tools (do not use loopback device).
}

%
\declareAttribute{PMIX_SERVER_SYSTEM_SUPPORT}{"pmix.srvr.sys"}{bool}{
The host RM wants to declare itself as being the local system server for PMIx connection requests.
}

%
\declareAttribute{PMIX_SERVER_TMPDIR}{"pmix.srvr.tmpdir"}{char*}{
temp directory where PMIx server will place client rendezvous points and contact info.
}

%
\declareAttribute{PMIX_SYSTEM_TMPDIR}{"pmix.sys.tmpdir"}{char*}{
temp directory for this system, where PMIx server will place tool rendezvous points and contact info.
}

%
\declareAttribute{PMIX_REGISTER_NODATA}{"pmix.reg.nodata"}{bool}{
Registration is for nspace only, do not copy job data.
}

%
\declareAttribute{PMIX_SERVER_ENABLE_MONITORING}{"pmix.srv.monitor"}{bool}{
Enable PMIx internal monitoring by server
}

%
\declareAttribute{PMIX_SERVER_NSPACE}{"pmix.srv.nspace"}{char*}{
Name of the nspace to use for this server.
}

%
\declareAttribute{PMIX_SERVER_RANK}{"pmix.srv.rank"}{pmix_rank_t}{
Rank of this server
}


%%%%%%%%%%%
\subsubsection{Tool-related attributes}
\label{api:struct:attributes:tool}

\ldots

%
\declareAttribute{PMIX_TOOL_NSPACE}{"pmix.tool.nspace"}{char*}{
Name of the nspace to use for this tool.
}

%
\declareAttribute{PMIX_TOOL_RANK}{"pmix.tool.rank"}{uint32_t}{
Rank of this tool.
}

%
\declareAttribute{PMIX_SERVER_PIDINFO}{"pmix.srvr.pidinfo"}{pid_t}{
PID of the target server for a tool.
}

%
\declareAttribute{PMIX_CONNECT_TO_SYSTEM}{"pmix.cnct.sys"}{bool}{
The requestor requires that a connection be made only to a local system-level PMIx server.
}

%
\declareAttribute{PMIX_CONNECT_SYSTEM_FIRST}{"pmix.cnct.sys.first"}{bool}{
Preferentially look for a system-level PMIx server first.
}

%
\declareAttribute{PMIX_SERVER_URI}{"pmix.srvr.uri"}{char*}{
URI of server to be contacted.
}

%
\declareAttribute{PMIX_SERVER_HOSTNAME}{"pmix.srvr.host"}{char*}{
node where target server is located
}

%
\declareAttribute{PMIX_CONNECT_MAX_RETRIES}{"pmix.tool.mretries"}{uint32_t}{
maximum number of times to try to connect to server
}

%
\declareAttribute{PMIX_CONNECT_RETRY_DELAY}{"pmix.tool.retry"}{uint32_t}{
time in seconds between connection attempts
}

%
\declareAttribute{PMIX_TOOL_DO_NOT_CONNECT}{"pmix.tool.nocon"}{bool}{
The tool wants to use internal PMIx support, but does not want to connect to a PMIx server.
}


%%%%%%%%%%%
\subsubsection{Identification attributes}
\label{api:struct:attributes:ident}

\ldots

%
\declareAttribute{PMIX_USERID}{"pmix.euid"}{uint32_t}{
Effective user id
}

%
\declareAttribute{PMIX_GRPID}{"pmix.egid"}{uint32_t}{
Effective group id
}

%
\declareAttribute{PMIX_DSTPATH}{"pmix.dstpath"}{char*}{
Path to dstore files
}

%
\declareAttribute{PMIX_VERSION_INFO}{"pmix.version"}{char*}{
PMIx version of contactor
}

%
\declareAttribute{PMIX_PROGRAMMING_MODEL}{"pmix.pgm.model"}{char*}{
Programming model being initialized (e.g., ``MPI'' or ``OpenMP'')
}

%
\declareAttribute{PMIX_MODEL_LIBRARY_NAME}{"pmix.mdl.name"}{char*}{
Programming model implementation ID (e.g., ``OpenMPI'' or ``MPICH'')
}

%
\declareAttribute{PMIX_MODEL_LIBRARY_VERSION}{"pmix.mld.vrs"}{char*}{
Programming model version string (e.g., ``2.1.1'')
}

%
\declareAttribute{PMIX_THREADING_MODEL}{"pmix.threads"}{char*}{
Threading model used (e.g., ``pthreads'')
}

%
\declareAttribute{PMIX_REQUESTOR_IS_TOOL}{"pmix.req.tool"}{bool}{
Requesting process is a tool
}

%
\declareAttribute{PMIX_REQUESTOR_IS_CLIENT}{"pmix.req.client"}{bool}{
Requesting process is a client process
}


%%%%%%%%%%%
\subsubsection{USOCK rendezvous socket attributes}
\label{api:struct:attributes:usock}

\ldots

%
\declareAttribute{PMIX_USOCK_DISABLE}{"pmix.usock.disable"}{bool}{
Disable legacy usock support
}

%
\declareAttribute{PMIX_SOCKET_MODE}{"pmix.sockmode"}{uint32_t}{
POSIX \var{mode_t} (9 bits valid)
}

%
\declareAttribute{PMIX_SINGLE_LISTENER}{"pmix.sing.listnr"}{bool}{
Use only one rendezvous socket, letting priorities and/or MCA param select the active transport.
}


%%%%%%%%%%%
\subsubsection{TCP connection attributes}
\label{api:struct:attributes:tcp}

\ldots

%
\declareAttribute{PMIX_TCP_REPORT_URI}{"pmix.tcp.repuri"}{char*}{
output URI. '-' for stdout, '+' for stderr, or filename
}

%
\declareAttribute{PMIX_TCP_URI}{"pmix.tcp.uri"}{char*}{
URI of server to connect to, or \code{file:<name of file containing it>}
}

%
\declareAttribute{PMIX_TCP_IF_INCLUDE}{"pmix.tcp.ifinclude"}{char*}{
Comma-delimited list of devices and/or CIDR notation
}

%
\declareAttribute{PMIX_TCP_IF_EXCLUDE}{"pmix.tcp.ifexclude"}{char*}{
Comma-delimited list of devices and/or CIDR notation
}

%
\declareAttribute{PMIX_TCP_IPV4_PORT}{"pmix.tcp.ipv4"}{int}{
IPv4 port to be used
}

%
\declareAttribute{PMIX_TCP_IPV6_PORT}{"pmix.tcp.ipv6"}{int}{
IPv6 port to be used
}

%
\declareAttribute{PMIX_TCP_DISABLE_IPV4}{"pmix.tcp.disipv4"}{bool}{
true to disable IPv4 family
}

%
\declareAttribute{PMIX_TCP_DISABLE_IPV6}{"pmix.tcp.disipv6"}{bool}{
true to disable IPv6 family
}


%%%%%%%%%%%
\subsubsection{GDS attributes}
\label{api:struct:attributes:gds}

\ldots

%
\declareAttribute{PMIX_GDS_MODULE}{"pmix.gds.mod"}{char*}{
Comma-delimited string of desired modules
}


%%%%%%%%%%%
\subsubsection{General proc-level attributes}
\label{api:struct:attributes:gproc}

\ldots

%
\declareAttribute{PMIX_CPUSET}{"pmix.cpuset"}{char*}{
hwloc bitmap applied to proc upon launch
}

%
\declareAttribute{PMIX_CREDENTIAL}{"pmix.cred"}{char*}{
Security credential assigned to proc
}

%
\declareAttribute{PMIX_SPAWNED}{"pmix.spawned"}{bool}{
true if this proc resulted from a call to \refapi{PMIx_Spawn}
}

%
\declareAttribute{PMIX_ARCH}{"pmix.arch"}{uint32_t}{
datatype architecture flag
}

%%%%%%%%%%%
\subsubsection{Scratch directory locations for use by applications attributes}
\label{api:struct:attributes:scratchdir}

\ldots

%
\declareAttribute{PMIX_TMPDIR}{"pmix.tmpdir"}{char*}{
Top-level tmp dir assigned to session
}

%
\declareAttribute{PMIX_NSDIR}{"pmix.nsdir"}{char*}{
Sub-tmpdir assigned to namespace
}

%
\declareAttribute{PMIX_PROCDIR}{"pmix.pdir"}{char*}{
Sub-nsdir assigned to proc
}

%
\declareAttribute{PMIX_TDIR_RMCLEAN}{"pmix.tdir.rmclean"}{bool}{
Resource Manager will clean session directories
}


%%%%%%%%%%%
\subsubsection{Information about relative ranks as assigned by the RM attributes}
\label{api:struct:attributes:relrankinfo}

\ldots

%
\declareAttribute{PMIX_PROCID}{"pmix.procid"}{pmix_proc_t}{
Process identifier
}

%
\declareAttribute{PMIX_NSPACE}{"pmix.nspace"}{char*}{
nspace of a job
}

%
\declareAttribute{PMIX_JOBID}{"pmix.jobid"}{char*}{
jobid assigned by scheduler
}

%
\declareAttribute{PMIX_APPNUM}{"pmix.appnum"}{uint32_t}{
app number within the job
}

%
\declareAttribute{PMIX_RANK}{"pmix.rank"}{pmix_rank_t}{
process rank within the job
}

%
\declareAttribute{PMIX_GLOBAL_RANK}{"pmix.grank"}{pmix_rank_t}{
rank spanning across all jobs in this session
}

%
\declareAttribute{PMIX_APP_RANK}{"pmix.apprank"}{pmix_rank_t}{
rank within this app
}

%
\declareAttribute{PMIX_NPROC_OFFSET}{"pmix.offset"}{pmix_rank_t}{
starting global rank of this job
}

%
\declareAttribute{PMIX_LOCAL_RANK}{"pmix.lrank"}{uint16_t}{
rank on this node within this job
}

%
\declareAttribute{PMIX_NODE_RANK}{"pmix.nrank"}{uint16_t}{
rank on this node spanning all jobs
}

%
\declareAttribute{PMIX_LOCALLDR}{"pmix.lldr"}{pmix_rank_t}{
lowest rank on this node within this job
}

%
\declareAttribute{PMIX_APPLDR}{"pmix.aldr"}{pmix_rank_t}{
lowest rank in this app within this job
}

%
\declareAttribute{PMIX_PROC_PID}{"pmix.ppid"}{pid_t}{
pid of specified proc
}

%
\declareAttribute{PMIX_SESSION_ID}{"pmix.session.id"}{uint32_t}{
ession identifier
}

%
\declareAttribute{PMIX_NODE_LIST}{"pmix.nlist"}{char*}{
Comma-delimited list of nodes running procs for the specified nspace
}

%
\declareAttribute{PMIX_ALLOCATED_NODELIST}{"pmix.alist"}{char*}{
comma-delimited list of all nodes in this allocation regardless of whether or not they currently host procs.
}

%
\declareAttribute{PMIX_HOSTNAME}{"pmix.hname"}{char*}{
Name of the host the specified proc is on
}

%
\declareAttribute{PMIX_NODEID}{"pmix.nodeid"}{uint32_t}{
Node identifier where the specified proc is located
}

%
\declareAttribute{PMIX_LOCAL_PEERS}{"pmix.lpeers"}{char*}{
Comma-delimited string of ranks on this node within the specified nspace
}

%
\declareAttribute{PMIX_LOCAL_PROCS}{"pmix.lprocs"}{pmix_proc_t array}{
array of pmix_proc_t of procs on the specified node
}

%
\declareAttribute{PMIX_LOCAL_CPUSETS}{"pmix.lcpus"}{char*}{
colon-delimited cpusets of local peers within the specified nspace
}

%
\declareAttribute{PMIX_PROC_URI}{"pmix.puri"}{char*}{
URI containing contact info for proc
}

%
\declareAttribute{PMIX_LOCALITY}{"pmix.loc"}{uint16_t}{
relative locality of two procs
}

%
\declareAttribute{PMIX_PARENT_ID}{"pmix.parent"}{pmix_proc_t}{
process identifier of my parent process
}

%%%%%%%%%%%
\subsubsection{Size information attributes}
\label{api:struct:attributes:sizeinfo}

\ldots

%
\declareAttribute{PMIX_UNIV_SIZE}{"pmix.univ.size"}{uint32_t}{
Number of procs in this nspace
}

%
\declareAttribute{PMIX_JOB_SIZE}{"pmix.job.size"}{uint32_t}{
Number of procs in this job
}

%
\declareAttribute{PMIX_JOB_NUM_APPS}{"pmix.job.napps"}{uint32_t}{
Number of apps in this job
}

%
\declareAttribute{PMIX_APP_SIZE}{"pmix.app.size"}{uint32_t}{
Number of procs in this application
}

%
\declareAttribute{PMIX_LOCAL_SIZE}{"pmix.local.size"}{uint32_t}{
Number of procs in this job on this node
}

%
\declareAttribute{PMIX_NODE_SIZE}{"pmix.node.size"}{uint32_t}{
Number of procs across all jobs on this node
}

%
\declareAttribute{PMIX_MAX_PROCS}{"pmix.max.size"}{uint32_t}{
Max number of procs for this job
}

%
\declareAttribute{PMIX_NUM_NODES}{"pmix.num.nodes"}{uint32_t}{
Number of nodes in this nspace
}

%%%%%%%%%%%
\subsubsection{Memory information attributes}
\label{api:struct:attributes:meminfo}

\ldots

%
\declareAttribute{PMIX_AVAIL_PHYS_MEMORY}{"pmix.pmem"}{uint64_t}{
Total available physical memory on this node
}

%
\declareAttribute{PMIX_DAEMON_MEMORY}{"pmix.dmn.mem"}{float}{
Mbytes of memory currently used by daemon
}

%
\declareAttribute{PMIX_CLIENT_AVG_MEMORY}{"pmix.cl.mem.avg"}{float}{
Average Mbytes of memory used by client processes
}

%%%%%%%%%%%
\subsubsection{Topology information attributes}
\label{api:struct:attributes:topoinfo}

\ldots

%
\declareAttribute{PMIX_NET_TOPO}{"pmix.ntopo"}{char*}{
xml-representation of network topology
}

%
\declareAttribute{PMIX_LOCAL_TOPO}{"pmix.ltopo"}{char*}{
xml-representation of local node topology
}

%
\declareAttribute{PMIX_NODE_LIST}{"pmix.nlist"}{char*}{
comma-delimited list of nodes running procs for this job
}

%
\declareAttribute{PMIX_TOPOLOGY}{"pmix.topo"}{hwloc_topology_t}{
pointer to the PMIx client's internal topology object
}

%
\declareAttribute{PMIX_TOPOLOGY_SIGNATURE}{"pmix.toposig"}{char*}{
topology signature string
}

%
\declareAttribute{PMIX_LOCALITY_STRING}{"pmix.locstr"}{char*}{
string describing a proc's location
}

%
\declareAttribute{PMIX_HWLOC_SHMEM_ADDR}{"pmix.hwlocaddr"}{size_t}{
address of HWLOC shared memory segment
}

%
\declareAttribute{PMIX_HWLOC_SHMEM_SIZE}{"pmix.hwlocsize"}{size_t}{
size of HWLOC shared memory segment
}

%
\declareAttribute{PMIX_HWLOC_SHMEM_FILE}{"pmix.hwlocfile"}{char*}{
path to HWLOC shared memory file
}

%
\declareAttribute{PMIX_HWLOC_XML_V1}{"pmix.hwlocxml1"}{char*}{
XML representation of local topology using HWLOC v1.x format
}

%
\declareAttribute{PMIX_HWLOC_XML_V2}{"pmix.hwlocxml2"}{char*}{
XML representation of local topology using HWLOC v2.x format
}

%%%%%%%%%%%
\subsubsection{Request-related attributes}
\label{api:struct:attributes:request}

\ldots

%
\declareAttribute{PMIX_COLLECT_DATA}{"pmix.collect"}{bool}{
Collect data and return it at the end of the operation
}

%
\declareAttribute{PMIX_TIMEOUT}{"pmix.timeout"}{int}{
Time in sec before specified operation should time out (0 indicating infinite) in error.
The timeout parameter can help avoid ``hangs'' due to programming errors that prevent the target proc from ever exposing its data.
}

%
\declareAttribute{PMIX_IMMEDIATE}{"pmix.immediate"}{bool}{
Specified operation should immediately return an error from the PMIx server if requested data cannot be found - do not request it from the host RM.
}

%
\declareAttribute{PMIX_WAIT}{"pmix.wait"}{int}{
Caller requests that the server wait until at least the specified number of values are found (0 indicates all and is the default)
}

%
\declareAttribute{PMIX_COLLECTIVE_ALGO}{"pmix.calgo"}{char*}{
comma-delimited list of algorithms to use for collective
}

%
\declareAttribute{PMIX_COLLECTIVE_ALGO_REQD}{"pmix.calreqd"}{bool}{
if true, indicates that the requested choice of algo is mandatory
}

%
\declareAttribute{PMIX_NOTIFY_COMPLETION}{"pmix.notecomp"}{bool}{
notify parent process upon termination of child job
}

%
\declareAttribute{PMIX_RANGE}{"pmix.range"}{pmix_data_range_t}{
value for calls to publish/lookup/unpublish or for monitoring event notifications
}

%
\declareAttribute{PMIX_PERSISTENCE}{"pmix.persist"}{pmix_persistence_t}{
value for calls to publish
}

%
\declareAttribute{PMIX_DATA_SCOPE}{"pmix.scope"}{pmix_scope_t}{
Scope of the data to be found in a \refapi{PMIx_Get} call
}

%
\declareAttribute{PMIX_OPTIONAL}{"pmix.optional"}{bool}{
look only in the client's local data store for the requested value - do not request data from the server if not found
}

%
\declareAttribute{PMIX_EMBED_BARRIER}{"pmix.embed.barrier"}{bool}{
Execute a blocking fence operation before executing the specified operation.
By default, \refapi{PMIx_Finalize} does not include an internal barrier operation.
This attribute directs \refapi{PMIx_Finalize} to execute a barrier as part of the finalize operation.
}

%
\declareAttribute{PMIX_JOB_TERM_STATUS}{"pmix.job.term.status"}{pmix_status_t}{
status returned upon job termination
}

%
\declareAttribute{PMIX_PROC_STATE_STATUS}{"pmix.proc.state"}{pmix_proc_state_t}{
process state
}

%%%%%%%%%%%
\subsubsection{Sever to Convenience library attributes}
\label{api:struct:attributes:server2cl}

Attributes used by host server to pass data to the server convenience library - the data will then be parsed and provided to the local clients.

%
\declareAttribute{PMIX_REGISTER_NODATA}{"pmix.reg.nodata"}{bool}{
Registration is for nspace only, do not copy job data
}

%
\declareAttribute{PMIX_PROC_DATA}{"pmix.pdata"}{pmix_data_array_t}{
starts with rank, then contains more data
}

%
\declareAttribute{PMIX_NODE_MAP}{"pmix.nmap"}{char*}{
regex of nodes containing procs for this job
}

%
\declareAttribute{PMIX_PROC_MAP}{"pmix.pmap"}{char*}{
regex describing procs on each node within this job
}

%
\declareAttribute{PMIX_ANL_MAP}{"pmix.anlmap"}{char*}{
process mapping in ANL notation (used in PMI-1/PMI-2)
}

%
\declareAttribute{PMIX_APP_MAP_TYPE}{"pmix.apmap.type"}{char*}{
type of mapping used to layout the application (e.g., cyclic)
}

%
\declareAttribute{PMIX_APP_MAP_REGEX}{"pmix.apmap.regex"}{char*}{
regex describing the result of the mapping
}


%%%%%%%%%%%
\subsubsection{Sever to Client attributes}
\label{api:struct:attributes:server2client}

Attributes used internally to communicate data from the server to the client

%
\declareAttribute{PMIX_PROC_BLOB}{"pmix.pblob"}{pmix_byte_object_t}{
packed blob of process data
}

%
\declareAttribute{PMIX_MAP_BLOB}{"pmix.mblob"}{pmix_byte_object_t}{
packed blob of process location
}

%%%%%%%%%%%
\subsubsection{Event handler registration and notification attributes}
\label{api:struct:attributes:event}

\ldots

%
\declareAttribute{PMIX_EVENT_HDLR_NAME}{"pmix.evname"}{char*}{
string name identifying this handler
}

%
\declareAttribute{PMIX_EVENT_JOB_LEVEL}{"pmix.evjob"}{bool}{
register for job-specific events only
}

%
\declareAttribute{PMIX_EVENT_ENVIRO_LEVEL}{"pmix.evenv"}{bool}{
register for environment events only
}

%
\declareAttribute{PMIX_EVENT_HDLR_FIRST}{"pmix.evfirst"}{bool}{
invoke this event handler before any other handlers
}

%
\declareAttribute{PMIX_EVENT_HDLR_LAST}{"pmix.evlast"}{bool}{
invoke this event handler after all other handlers have been called
}

%
\declareAttribute{PMIX_EVENT_HDLR_FIRST_IN_CATEGORY}{"pmix.evfirstcat"}{bool}{
invoke this event handler before any other handlers in this category
}

%
\declareAttribute{PMIX_EVENT_HDLR_LAST_IN_CATEGORY}{"pmix.evlastcat"}{bool}{
invoke this event handler after all other handlers in this category have been called
}

%
\declareAttribute{PMIX_EVENT_HDLR_BEFORE}{"pmix.evbefore"}{char*}{
put this event handler immediately before the one specified in the (char*) value
}

%
\declareAttribute{PMIX_EVENT_HDLR_AFTER}{"pmix.evafter"}{char*}{
put this event handler immediately after the one specified in the (char*) value
}

%
\declareAttribute{PMIX_EVENT_HDLR_PREPEND}{"pmix.evprepend"}{bool}{
prepend this handler to the precedence list within its category
}

%
\declareAttribute{PMIX_EVENT_HDLR_APPEND}{"pmix.evappend"}{bool}{
append this handler to the precedence list within its category
}

%
\declareAttribute{PMIX_EVENT_CUSTOM_RANGE}{"pmix.evrange"}{pmix_data_array_t*}{
array of pmix_proc_t defining range of event notification
}

%
\declareAttribute{PMIX_EVENT_AFFECTED_PROC}{"pmix.evproc"}{pmix_proc_t}{
single proc that was affected
}

%
\declareAttribute{PMIX_EVENT_AFFECTED_PROCS}{"pmix.evaffected"}{pmix_data_array_t*}{
array of pmix_proc_t defining affected procs
}

%
\declareAttribute{PMIX_EVENT_NON_DEFAULT}{"pmix.evnondef"}{bool}{
event is not to be delivered to default event handlers
}

%
\declareAttribute{PMIX_EVENT_RETURN_OBJECT}{"pmix.evobject"}{void*}{
object to be returned whenever the registered cbfunc is invoked.
NOTE: the object will \emph{only} be returned to the process that registered it.
}

%
\declareAttribute{PMIX_EVENT_DO_NOT_CACHE}{"pmix.evnocache"}{bool}{
instruct the PMIx server not to cache the event
}

%
\declareAttribute{PMIX_EVENT_SILENT_TERMINATION}{"pmix.evsilentterm"}{bool}{
do not generate an event when this job normally terminates
}

%%%%%%%%%%%
\subsubsection{Fault tolerance attributes}
\label{api:struct:attributes:faulttolerance}

\ldots

%
\declareAttribute{PMIX_EVENT_TERMINATE_SESSION}{"pmix.evterm.sess"}{bool}{
RM intends to terminate session
}

%
\declareAttribute{PMIX_EVENT_TERMINATE_JOB}{"pmix.evterm.job"}{bool}{
RM intends to terminate this job
}

%
\declareAttribute{PMIX_EVENT_TERMINATE_NODE}{"pmix.evterm.node"}{bool}{
RM intends to terminate all procs on this node
}

%
\declareAttribute{PMIX_EVENT_TERMINATE_PROC}{"pmix.evterm.proc"}{bool}{
RM intends to terminate just this process
}

%
\declareAttribute{PMIX_EVENT_ACTION_TIMEOUT}{"pmix.evtimeout"}{int}{
time in sec before RM will execute error response
}

%
\declareAttribute{PMIX_EVENT_NO_TERMINATION}{"pmix.evnoterm"}{bool}{
indicates that the handler has satisfactorily handled the event and believes termination of the application is not required.
}

%
\declareAttribute{PMIX_EVENT_WANT_TERMINATION}{"pmix.evterm"}{bool}{
indicates that the handler has determined that the application should be terminated
}

%%%%%%%%%%%
\subsubsection{Spawn attributes}
\label{api:struct:attributes:spawn}

attributes used to describe "spawn" attributes

%
\declareAttribute{PMIX_PERSONALITY}{"pmix.pers"}{char*}{
name of personality to use
}

%
\declareAttribute{PMIX_HOST}{"pmix.host"}{char*}{
comma-delimited list of hosts to use for spawned procs
}

%
\declareAttribute{PMIX_HOSTFILE}{"pmix.hostfile"}{char*}{
hostfile to use for spawned procs
}

%
\declareAttribute{PMIX_ADD_HOST}{"pmix.addhost"}{char*}{
comma-delimited list of hosts to add to allocation
}

%
\declareAttribute{PMIX_ADD_HOSTFILE}{"pmix.addhostfile"}{char*}{
hostfile to add to existing allocation
}

%
\declareAttribute{PMIX_PREFIX}{"pmix.prefix"}{char*}{
prefix to use for starting spawned procs
}

%
\declareAttribute{PMIX_WDIR}{"pmix.wdir"}{char*}{
working directory for spawned procs
}

%
\declareAttribute{PMIX_MAPPER}{"pmix.mapper"}{char*}{
mapper to use for placing spawned procs
}

%
\declareAttribute{PMIX_DISPLAY_MAP}{"pmix.dispmap"}{bool}{
display process map upon spawn
}

%
\declareAttribute{PMIX_PPR}{"pmix.ppr"}{char*}{
Number of procs to spawn on each identified resource
}

%
\declareAttribute{PMIX_MAPBY}{"pmix.mapby"}{char*}{
mapping policy
}

%
\declareAttribute{PMIX_RANKBY}{"pmix.rankby"}{char*}{
ranking policy
}

%
\declareAttribute{PMIX_BINDTO}{"pmix.bindto"}{char*}{
binding policy
}

%
\declareAttribute{PMIX_PRELOAD_BIN}{"pmix.preloadbin"}{bool}{
preload binaries
}

%
\declareAttribute{PMIX_PRELOAD_FILES}{"pmix.preloadfiles"}{char*}{
comma-delimited list of files to pre-position
}

%
\declareAttribute{PMIX_NON_PMI}{"pmix.nonpmi"}{bool}{
spawned procs will not call \refapi{PMIx_Init}
}

%
\declareAttribute{PMIX_STDIN_TGT}{"pmix.stdin"}{uint32_t}{
spawned proc rank that is to receive stdin
}

%
\declareAttribute{PMIX_FWD_STDIN}{"pmix.fwd.stdin"}{bool}{
forward my stdin to the designated proc
}

%
\declareAttribute{PMIX_FWD_STDOUT}{"pmix.fwd.stdout"}{bool}{
forward stdout from spawned procs to me
}

%
\declareAttribute{PMIX_FWD_STDERR}{"pmix.fwd.stderr"}{bool}{
forward stderr from spawned procs to me
}

%
\declareAttribute{PMIX_DEBUGGER_DAEMONS}{"pmix.debugger"}{bool}{
spawned app consists of debugger daemons
}

%
\declareAttribute{PMIX_COSPAWN_APP}{"pmix.cospawn"}{bool}{
designated app is to be spawned as a disconnected job - i.e., not part of the "comm_world" of the job
}

%
\declareAttribute{PMIX_SET_SESSION_CWD}{"pmix.ssncwd"}{bool}{
set the application's current working directory to the session working directory assigned by the RM
}

%
\declareAttribute{PMIX_TAG_OUTPUT}{"pmix.tagout"}{bool}{
tag application output with the ID of the source
}

%
\declareAttribute{PMIX_TIMESTAMP_OUTPUT}{"pmix.tsout"}{bool}{
timestamp output from applications
}

%
\declareAttribute{PMIX_MERGE_STDERR_STDOUT}{"pmix.mergeerrout"}{bool}{
merge stdout and stderr streams from application procs
}

%
\declareAttribute{PMIX_OUTPUT_TO_FILE}{"pmix.outfile"}{char*}{
output application output to given file
}

%
\declareAttribute{PMIX_INDEX_ARGV}{"pmix.indxargv"}{bool}{
mark the argv with the rank of the proc
}

%
\declareAttribute{PMIX_CPUS_PER_PROC}{"pmix.cpuperproc"}{uint32_t}{
Number of cpus to assign to each rank
}

%
\declareAttribute{PMIX_NO_PROCS_ON_HEAD}{"pmix.nolocal"}{bool}{
do not place procs on the head node
}

%
\declareAttribute{PMIX_NO_OVERSUBSCRIBE}{"pmix.noover"}{bool}{
do not oversubscribe the cpus
}

%
\declareAttribute{PMIX_REPORT_BINDINGS}{"pmix.repbind"}{bool}{
report bindings of the individual procs
}

%
\declareAttribute{PMIX_CPU_LIST}{"pmix.cpulist"}{char*}{
list of cpus to use for this job
}

%
\declareAttribute{PMIX_JOB_RECOVERABLE}{"pmix.recover"}{bool}{
application supports recoverable operations
}

%
\declareAttribute{PMIX_JOB_CONTINUOUS}{"pmix.continuous"}{bool}{
application is continuous, all failed procs should be immediately restarted.
}

%
\declareAttribute{PMIX_MAX_RESTARTS}{"pmix.maxrestarts"}{uint32_t}{
max number of times to restart a job
}

%%%%%%%%%%%
\subsubsection{Query attributes}
\label{api:struct:attributes:query}

\ldots

%
\declareAttribute{PMIX_QUERY_NAMESPACES}{"pmix.qry.ns"}{char*}{
request a comma-delimited list of active nspaces
}

%
\declareAttribute{PMIX_QUERY_JOB_STATUS}{"pmix.qry.jst"}{pmix_status_t}{
status of a specified currently executing job
}

%
\declareAttribute{PMIX_QUERY_QUEUE_LIST}{"pmix.qry.qlst"}{char*}{
request a comma-delimited list of scheduler queues
}

%
\declareAttribute{PMIX_QUERY_QUEUE_STATUS}{"pmix.qry.qst"}{TBD}{
status of a specified scheduler queue
}

%
\declareAttribute{PMIX_QUERY_PROC_TABLE}{"pmix.qry.ptable"}{char*}{
input nspace of job whose info is being requested returns (pmix_data_array_t) an array of pmix_proc_info_t.
}

%
\declareAttribute{PMIX_QUERY_LOCAL_PROC_TABLE}{"pmix.qry.lptable"}{char*}{
input nspace of job whose info is being requested returns (pmix_data_array_t) an array of pmix_proc_info_t for procs in job on same node
}

%
\declareAttribute{PMIX_QUERY_AUTHORIZATIONS}{"pmix.qry.auths"}{bool}{
return operations tool is authorized to perform
}

%
\declareAttribute{PMIX_QUERY_SPAWN_SUPPORT}{"pmix.qry.spawn"}{bool}{
return a comma-delimited list of supported spawn attributes
}

%
\declareAttribute{PMIX_QUERY_DEBUG_SUPPORT}{"pmix.qry.debug"}{bool}{
return a comma-delimited list of supported debug attributes
}

%
\declareAttribute{PMIX_QUERY_MEMORY_USAGE}{"pmix.qry.mem"}{bool}{
return info on memory usage for the procs indicated in the qualifiers
}

%
\declareAttribute{PMIX_QUERY_LOCAL_ONLY}{"pmix.qry.local"}{bool}{
constrain the query to local information only
}

%
\declareAttribute{PMIX_QUERY_REPORT_AVG}{"pmix.qry.avg"}{bool}{
report average values
}

%
\declareAttribute{PMIX_QUERY_REPORT_MINMAX}{"pmix.qry.minmax"}{bool}{
report minimum and maximum value
}

%
\declareAttribute{PMIX_QUERY_ALLOC_STATUS}{"pmix.query.alloc"}{char*}{
string identifier of the allocation whose status is being requested
}

%
\declareAttribute{PMIX_TIME_REMAINING}{"pmix.time.remaining"}{char*}{
query number of seconds (uint32_t) remaining in allocation for the specified nspace
}

%%%%%%%%%%%
\subsubsection{Log attributes}
\label{api:struct:attributes:log}

\ldots

%
\declareAttribute{PMIX_LOG_STDERR}{"pmix.log.stderr"}{char*}{
log string to stderr
}

%
\declareAttribute{PMIX_LOG_STDOUT}{"pmix.log.stdout"}{char*}{
log string to stdout
}

%
\declareAttribute{PMIX_LOG_SYSLOG}{"pmix.log.syslog"}{char*}{
log data to syslog - defaults to ERROR priority unless
}

%
\declareAttribute{PMIX_LOG_MSG}{"pmix.log.msg"}{pmix_byte_object_t}{
message blob to be sent somewhere
}

%
\declareAttribute{PMIX_LOG_EMAIL}{"pmix.log.email"}{pmix_data_array_t}{
log via email based on pmix_info_t containing directives
}

%
\declareAttribute{PMIX_LOG_EMAIL_ADDR}{"pmix.log.emaddr"}{char*}{
comma-delimited list of email addresses that are to recv msg
}

%
\declareAttribute{PMIX_LOG_EMAIL_SUBJECT}{"pmix.log.emsub"}{char*}{
subject line for email
}

%
\declareAttribute{PMIX_LOG_EMAIL_MSG}{"pmix.log.emmsg"}{char*}{
msg to be included in email
}

%%%%%%%%%%%
\subsubsection{Debugger attributes}
\label{api:struct:attributes:debugger}

\ldots

%
\declareAttribute{PMIX_DEBUG_STOP_ON_EXEC}{"pmix.dbg.exec"}{bool}{
job is being spawned under debugger - instruct it to pause on start
}

%
\declareAttribute{PMIX_DEBUG_STOP_IN_INIT}{"pmix.dbg.init"}{bool}{
instruct job to stop during PMIx init
}

%
\declareAttribute{PMIX_DEBUG_WAIT_FOR_NOTIFY}{"pmix.dbg.notify"}{bool}{
block at desired point until receiving debugger release notification
}

%
\declareAttribute{PMIX_DEBUG_JOB}{"pmix.dbg.job"}{char*}{
nspace of the job to be debugged - the RM/PMIx server are
}

%
\declareAttribute{PMIX_DEBUG_WAITING_FOR_NOTIFY}{"pmix.dbg.waiting"}{bool}{
job to be debugged is waiting for a release
}

%%%%%%%%%%%
\subsubsection{Resource manager attributes}
\label{api:struct:attributes:rm}

\ldots

%
\declareAttribute{PMIX_RM_NAME}{"pmix.rm.name"}{char*}{
string name of the resource manager
}

%
\declareAttribute{PMIX_RM_VERSION}{"pmix.rm.version"}{char*}{
RM version string
}


%%%%%%%%%%%
\subsubsection{Environment variable attributes}
\label{api:struct:attributes:envar}

\ldots

%
\declareAttribute{PMIX_SET_ENVAR}{"pmix.set.envar"}{char*}{
string "key=value" value shall be put into the environment
}

%
\declareAttribute{PMIX_UNSET_ENVAR}{"pmix.unset.envar"}{char*}{
unset envar specified in string
}


%%%%%%%%%%%
\subsubsection{Job Allocation attributes}
\label{api:struct:attributes:joballoc}

\ldots

%
\declareAttribute{PMIX_ALLOC_ID}{"pmix.alloc.id"}{char*}{
provide a string identifier for this allocation request which can later be used to query status of the request
}

%
\declareAttribute{PMIX_ALLOC_NUM_NODES}{"pmix.alloc.nnodes"}{uint64_t}{
number of nodes
}

%
\declareAttribute{PMIX_ALLOC_NODE_LIST}{"pmix.alloc.nlist"}{char*}{
regex of specific nodes
}

%
\declareAttribute{PMIX_ALLOC_NUM_CPUS}{"pmix.alloc.ncpus"}{uint64_t}{
number of cpus
}

%
\declareAttribute{PMIX_ALLOC_NUM_CPU_LIST}{"pmix.alloc.ncpulist"}{char*}{
regex of the number of cpus for each node
}

%
\declareAttribute{PMIX_ALLOC_CPU_LIST}{"pmix.alloc.cpulist"}{char*}{
regex of specific cpus indicating the cpus involved.
}

%
\declareAttribute{PMIX_ALLOC_MEM_SIZE}{"pmix.alloc.msize"}{float}{
number of Mbytes
}

%
\declareAttribute{PMIX_ALLOC_NETWORK}{"pmix.alloc.net"}{array}{
array of pmix_info_t describing network resources.
If not given as part of an info struct that identifies the impacted nodes, then the description will be applied across all nodes in the requestor's allocation
}

%
\declareAttribute{PMIX_ALLOC_NETWORK_ID}{"pmix.alloc.netid"}{char*}{
name of network
}

%
\declareAttribute{PMIX_ALLOC_BANDWIDTH}{"pmix.alloc.bw"}{float}{
Mbits/sec
}

%
\declareAttribute{PMIX_ALLOC_NETWORK_QOS}{"pmix.alloc.netqos"}{char*}{
quality of service level
}

%
\declareAttribute{PMIX_ALLOC_TIME}{"pmix.alloc.time"}{uint32_t}{
time in seconds
}


%%%%%%%%%%%
\subsubsection{Job control attributes}
\label{api:struct:attributes:jobcontrol}

\ldots

%
\declareAttribute{PMIX_JOB_CTRL_ID}{"pmix.jctrl.id"}{char*}{
provide a string identifier for this request
}

%
\declareAttribute{PMIX_JOB_CTRL_PAUSE}{"pmix.jctrl.pause"}{bool}{
pause the specified processes
}

%
\declareAttribute{PMIX_JOB_CTRL_RESUME}{"pmix.jctrl.resume"}{bool}{
``un-pause'' the specified processes
}

%
\declareAttribute{PMIX_JOB_CTRL_CANCEL}{"pmix.jctrl.cancel"}{char*}{
cancel the specified request (\code{NULL} implies cancel all requests from this requestor)
}

%
\declareAttribute{PMIX_JOB_CTRL_KILL}{"pmix.jctrl.kill"}{bool}{
forcibly terminate the specified processes and cleanup
}

%
\declareAttribute{PMIX_JOB_CTRL_RESTART}{"pmix.jctrl.restart"}{char*}{
restart the specified processes using the given checkpoint ID
}

%
\declareAttribute{PMIX_JOB_CTRL_CHECKPOINT}{"pmix.jctrl.ckpt"}{char*}{
checkpoint the specified processes and assign the given ID to it
}

%
\declareAttribute{PMIX_JOB_CTRL_CHECKPOINT_EVENT}{"pmix.jctrl.ckptev"}{bool}{
use event notification to trigger process checkpoint
}

%
\declareAttribute{PMIX_JOB_CTRL_CHECKPOINT_SIGNAL}{"pmix.jctrl.ckptsig"}{int}{
use the given signal to trigger process checkpoint
}

%
\declareAttribute{PMIX_JOB_CTRL_CHECKPOINT_TIMEOUT}{"pmix.jctrl.ckptsig"}{int}{
time in seconds to wait for checkpoint to complete
}

%
\declareAttribute{PMIX_JOB_CTRL_CHECKPOINT_METHOD}{"pmix.jctrl.ckmethod"}{pmix_data_array_t}{
array of pmix_info_t declaring each method and value supported by this application
}

%
\declareAttribute{PMIX_JOB_CTRL_SIGNAL}{"pmix.jctrl.sig"}{int}{
send given signal to specified processes
}

%
\declareAttribute{PMIX_JOB_CTRL_PROVISION}{"pmix.jctrl.pvn"}{char*}{
regex identifying nodes that are to be provisioned
}

%
\declareAttribute{PMIX_JOB_CTRL_PROVISION_IMAGE}{"pmix.jctrl.pvnimg"}{char*}{
name of the image that is to be provisioned
}

%
\declareAttribute{PMIX_JOB_CTRL_PREEMPTIBLE}{"pmix.jctrl.preempt"}{bool}{
job can be pre-empted
}

%
\declareAttribute{PMIX_JOB_CTRL_TERMINATE}{"pmix.jctrl.term"}{bool}{
politely terminate the specified procs
}

%%%%%%%%%%%
\subsubsection{Monitoring attributes}
\label{api:struct:attributes:monitor}

\ldots

%
\declareAttribute{PMIX_MONITOR_ID}{"pmix.monitor.id"}{char*}{
provide a string identifier for this request
}

%
\declareAttribute{PMIX_MONITOR_CANCEL}{"pmix.monitor.cancel"}{char*}{
identifier to be canceled (NULL means cancel all monitoring for this process)
}

%
\declareAttribute{PMIX_MONITOR_APP_CONTROL}{"pmix.monitor.appctrl"}{bool}{
the application desires to control the response to a monitoring event
}

%
\declareAttribute{PMIX_MONITOR_HEARTBEAT}{"pmix.monitor.mbeat"}{void}{
register to have the server monitor the requestor for heartbeats
}

%
\declareAttribute{PMIX_SEND_HEARTBEAT}{"pmix.monitor.beat"}{void}{
send heartbeat to local server
}

%
\declareAttribute{PMIX_MONITOR_HEARTBEAT_TIME}{"pmix.monitor.btime"}{uint32_t}{
time in seconds before declaring heartbeat missed
}

%
\declareAttribute{PMIX_MONITOR_HEARTBEAT_DROPS}{"pmix.monitor.bdrop"}{uint32_t}{
number of heartbeats that can be missed before generating the event
}

%
\declareAttribute{PMIX_MONITOR_FILE}{"pmix.monitor.fmon"}{char*}{
register to monitor file for signs of life
}

%
\declareAttribute{PMIX_MONITOR_FILE_SIZE}{"pmix.monitor.fsize"}{bool}{
monitor size of given file is growing to determine app is running
}

%
\declareAttribute{PMIX_MONITOR_FILE_ACCESS}{"pmix.monitor.faccess"}{char*}{
monitor time since last access of given file to determine app is running
}

%
\declareAttribute{PMIX_MONITOR_FILE_MODIFY}{"pmix.monitor.fmod"}{char*}{
monitor time since last modified of given file to determine app is running
}

%
\declareAttribute{PMIX_MONITOR_FILE_CHECK_TIME}{"pmix.monitor.ftime"}{uint32_t}{
time in seconds between checking file
}

%
\declareAttribute{PMIX_MONITOR_FILE_DROPS}{"pmix.monitor.fdrop"}{uint32_t}{
number of file checks that can be missed before generating the event
}


%%%%%%%%%%%
\subsection{Process state Definitions}
\label{api:struct:processstate}
\declarestruct{pmix_proc_state_t}

The \refstruct{pmix_proc_state_t} structure is an unsigned integer type (\code{uint8_t}) for process state values.

\begin{constantdesc}
%
\declareconstitem{PMIX_PROC_STATE_UNDEF}
undefined process state
%
\declareconstitem{PMIX_PROC_STATE_PREPPED}
process is ready to be launched
%
\declareconstitem{PMIX_PROC_STATE_LAUNCH_UNDERWAY}
launch process underway
%
\declareconstitem{PMIX_PROC_STATE_RESTART}
the proc is ready for restart
%
\declareconstitem{PMIX_PROC_STATE_TERMINATE}
process is marked for termination
%
\declareconstitem{PMIX_PROC_STATE_RUNNING}
daemon has locally fork'd process
%
\declareconstitem{PMIX_PROC_STATE_CONNECTED}
proc connected to PMIx server
%
\declareconstitem{PMIX_PROC_STATE_UNTERMINATED}
Define a ``boundary'' so users can easily and quickly determine  if a proc is still running or not - any value less than this one means that the proc has not terminated.
%
\declareconstitem{PMIX_PROC_STATE_TERMINATED}
process has terminated and is no longer running
%
\declareconstitem{PMIX_PROC_STATE_ERROR}
Define a boundary so users can easily and quickly determine if a proc abnormally terminated - leave a little room for future expansion.
%
\declareconstitem{PMIX_PROC_STATE_KILLED_BY_CMD}
process was killed by cmd
%
\declareconstitem{PMIX_PROC_STATE_ABORTED}
process aborted
%
\declareconstitem{PMIX_PROC_STATE_FAILED_TO_START}
process failed to start
%
\declareconstitem{PMIX_PROC_STATE_ABORTED_BY_SIG}
process aborted by signal
%
\declareconstitem{PMIX_PROC_STATE_TERM_WO_SYNC}
process exit'd without calling \refapi{PMIx_Finalize}
%
\declareconstitem{PMIX_PROC_STATE_COMM_FAILED}
process communication has failed
%
\declareconstitem{PMIX_PROC_STATE_CALLED_ABORT}
process called \refapi{PMIx_Abort}
%
\declareconstitem{PMIX_PROC_STATE_MIGRATING}
process failed and is waiting for resources before restarting
%
\declareconstitem{PMIX_PROC_STATE_CANNOT_RESTART}
process failed and cannot be restarted
%
\declareconstitem{PMIX_PROC_STATE_TERM_NON_ZERO}
process exited with a non-zero status, indicating abnormal
%
\declareconstitem{PMIX_PROC_STATE_FAILED_TO_LAUNCH}
unable to launch process
%
\end{constantdesc}


%%%%%%%%%%%
\subsection{Error Constants}
\label{api:struct:errors}
\declarestruct{pmix_status_t}

The \refstruct{pmix_status_t} structure is an integer type for return status.
The table below defines the possible values for \refstruct{pmix_status_t}.
PMIx errors are always negative, with 0 reserved for success.

\begin{constantdesc}
%
\declareconstitem{PMIX_ERR_BASE}
Error base
%
\end{constantdesc}

v1.x error values - must be fixed in place for backward compatability.
Note that some number of these have been deprecated and may not be returned by v2.x and above clients or servers.
However, they must always be at least defined to ensure older codes will compile.

%\begin{constantdesc}
%%
%\declareconstitem{ }
%
%%
%\end{constantdesc}

\cspecificstart
\begin{codepar}
//..
#define PMIX_SUCCESS                                 0
#define PMIX_ERROR                                  -1          // general error
#define PMIX_ERR_SILENT                             -2          // internal-only
/* debugger release flag */
#define PMIX_ERR_DEBUGGER_RELEASE                   -3
/* fault tolerance */
#define PMIX_ERR_PROC_RESTART                       -4
#define PMIX_ERR_PROC_CHECKPOINT                    -5
#define PMIX_ERR_PROC_MIGRATE                       -6
/* abort */
#define PMIX_ERR_PROC_ABORTED                       -7
#define PMIX_ERR_PROC_REQUESTED_ABORT               -8
#define PMIX_ERR_PROC_ABORTING                      -9
/* communication failures */
#define PMIX_ERR_SERVER_FAILED_REQUEST              -10
#define PMIX_EXISTS                                 -11
#define PMIX_ERR_INVALID_CRED                       -12         // internal-only
#define PMIX_ERR_HANDSHAKE_FAILED                   -13         // internal-only
#define PMIX_ERR_READY_FOR_HANDSHAKE                -14         // internal-only
#define PMIX_ERR_WOULD_BLOCK                        -15
#define PMIX_ERR_UNKNOWN_DATA_TYPE                  -16         // internal-only
#define PMIX_ERR_PROC_ENTRY_NOT_FOUND               -17         // internal-only
#define PMIX_ERR_TYPE_MISMATCH                      -18         // internal-only
#define PMIX_ERR_UNPACK_INADEQUATE_SPACE            -19         // internal-only
#define PMIX_ERR_UNPACK_FAILURE                     -20         // internal-only
#define PMIX_ERR_PACK_FAILURE                       -21         // internal-only
#define PMIX_ERR_PACK_MISMATCH                      -22         // internal-only
#define PMIX_ERR_NO_PERMISSIONS                     -23
#define PMIX_ERR_TIMEOUT                            -24
#define PMIX_ERR_UNREACH                            -25
#define PMIX_ERR_IN_ERRNO                           -26         // internal-only
#define PMIX_ERR_BAD_PARAM                          -27
#define PMIX_ERR_RESOURCE_BUSY                      -28         // internal-only
#define PMIX_ERR_OUT_OF_RESOURCE                    -29
#define PMIX_ERR_DATA_VALUE_NOT_FOUND               -30
#define PMIX_ERR_INIT                               -31
#define PMIX_ERR_NOMEM                              -32         // internal-only
#define PMIX_ERR_INVALID_ARG                        -33         // internal-only
#define PMIX_ERR_INVALID_KEY                        -34         // internal-only
#define PMIX_ERR_INVALID_KEY_LENGTH                 -35         // internal-only
#define PMIX_ERR_INVALID_VAL                        -36         // internal-only
#define PMIX_ERR_INVALID_VAL_LENGTH                 -37         // internal-only
#define PMIX_ERR_INVALID_LENGTH                     -38         // internal-only
#define PMIX_ERR_INVALID_NUM_ARGS                   -39         // internal-only
#define PMIX_ERR_INVALID_ARGS                       -40         // internal-only
#define PMIX_ERR_INVALID_NUM_PARSED                 -41         // internal-only
#define PMIX_ERR_INVALID_KEYVALP                    -42         // internal-only
#define PMIX_ERR_INVALID_SIZE                       -43
#define PMIX_ERR_INVALID_NAMESPACE                  -44
#define PMIX_ERR_SERVER_NOT_AVAIL                   -45         // internal-only
#define PMIX_ERR_NOT_FOUND                          -46
#define PMIX_ERR_NOT_SUPPORTED                      -47
#define PMIX_ERR_NOT_IMPLEMENTED                    -48
#define PMIX_ERR_COMM_FAILURE                       -49
#define PMIX_ERR_UNPACK_READ_PAST_END_OF_BUFFER     -50         // internal-only

/* define a starting point for v2.x error values */
#define PMIX_ERR_V2X_BASE                   -100

/* v2.x communication errors */
#define PMIX_ERR_LOST_CONNECTION_TO_SERVER      (PMIX_ERR_V2X_BASE -  1)
#define PMIX_ERR_LOST_PEER_CONNECTION           (PMIX_ERR_V2X_BASE -  2)
#define PMIX_ERR_LOST_CONNECTION_TO_CLIENT      (PMIX_ERR_V2X_BASE -  3)
/* used by the query system */
#define PMIX_QUERY_PARTIAL_SUCCESS              (PMIX_ERR_V2X_BASE -  4)
/* request responses */
#define PMIX_NOTIFY_ALLOC_COMPLETE              (PMIX_ERR_V2X_BASE -  5)
/* job control */
#define PMIX_JCTRL_CHECKPOINT                   (PMIX_ERR_V2X_BASE -  6)    // monitored by client to trigger checkpoint operation
#define PMIX_JCTRL_CHECKPOINT_COMPLETE          (PMIX_ERR_V2X_BASE -  7)    // sent by client and monitored by server to notify that requested
                                                                            //     checkpoint operation has completed
#define PMIX_JCTRL_PREEMPT_ALERT                (PMIX_ERR_V2X_BASE -  8)    // monitored by client to detect RM intends to preempt
/* monitoring */
#define PMIX_MONITOR_HEARTBEAT_ALERT            (PMIX_ERR_V2X_BASE -  9)
#define PMIX_MONITOR_FILE_ALERT                 (PMIX_ERR_V2X_BASE - 10)

/* define a starting point for operational error constants so
 * we avoid renumbering when making additions */
#define PMIX_ERR_OP_BASE    PMIX_ERR_V2X_BASE-30

/* operational */
#define PMIX_ERR_EVENT_REGISTRATION             (PMIX_ERR_OP_BASE - 14)
#define PMIX_ERR_JOB_TERMINATED                 (PMIX_ERR_OP_BASE - 15)
#define PMIX_ERR_UPDATE_ENDPOINTS               (PMIX_ERR_OP_BASE - 16)
#define PMIX_MODEL_DECLARED                     (PMIX_ERR_OP_BASE - 17)
#define PMIX_GDS_ACTION_COMPLETE                (PMIX_ERR_OP_BASE - 18)

/* define a starting point for system error constants so
 * we avoid renumbering when making additions */
#define PMIX_ERR_SYS_BASE    PMIX_ERR_OP_BASE-100

/* system failures */
#define PMIX_ERR_NODE_DOWN                      (PMIX_ERR_SYS_BASE -  1)
#define PMIX_ERR_NODE_OFFLINE                   (PMIX_ERR_SYS_BASE -  2)


/* define a starting point for event handler error constants so
 * we avoid renumbering when making additions */
#define PMIX_ERR_EVHDLR_BASE    PMIX_ERR_SYS_BASE-100

/* used by event handlers */
#define PMIX_EVENT_NO_ACTION_TAKEN              (PMIX_ERR_EVHDLR_BASE -  1)
#define PMIX_EVENT_PARTIAL_ACTION_TAKEN         (PMIX_ERR_EVHDLR_BASE -  2)
#define PMIX_EVENT_ACTION_DEFERRED              (PMIX_ERR_EVHDLR_BASE -  3)
#define PMIX_EVENT_ACTION_COMPLETE              (PMIX_ERR_EVHDLR_BASE -  4)

/* define a starting point for PMIx internal error codes
 * that are never exposed outside the library */
#define PMIX_INTERNAL_ERR_BASE          -1000

/* define a starting point for user-level defined error
 * constants - negative values larger than this are guaranteed
 * not to conflict with PMIx values. Definitions should always
 * be based on the PMIX_EXTERNAL_ERR_BASE constant and -not- a
 * specific value as the value of the constant may change */
#define PMIX_EXTERNAL_ERR_BASE           -2000
\end{codepar}
\cspecificend


%%%%%%%%%%%
\section{Data Types}

\ldots

%%%%%%%%%%%
\subsection{Packing Types}
\declarestruct{pmix_data_type_t}

The \refstruct{pmix_data_type_t} structure is an integer type for defining the data type for packing/unpacking purposes.
The table below defines the possible values for \refstruct{pmix_data_type_t}.

\cspecificstart
\begin{codepar}
// ...
#define PMIX_UNDEF               0
#define PMIX_BOOL                1  // converted to/from native true/false to uint8 for pack/unpack
#define PMIX_BYTE                2  // a byte of data
#define PMIX_STRING              3  // NULL-terminated string
#define PMIX_SIZE                4  // size_t
#define PMIX_PID                 5  // OS-pid
#define PMIX_INT                 6
#define PMIX_INT8                7
#define PMIX_INT16               8
#define PMIX_INT32               9
#define PMIX_INT64              10
#define PMIX_UINT               11
#define PMIX_UINT8              12
#define PMIX_UINT16             13
#define PMIX_UINT32             14
#define PMIX_UINT64             15
#define PMIX_FLOAT              16
#define PMIX_DOUBLE             17
#define PMIX_TIMEVAL            18
#define PMIX_TIME               19
#define PMIX_STATUS             20  // needs to be tracked separately from integer for those times
                                    // when we are embedded and it needs to be converted to the
                                    // host error definitions
#define PMIX_VALUE              21
#define PMIX_PROC               22
#define PMIX_APP                23
#define PMIX_INFO               24
#define PMIX_PDATA              25
#define PMIX_BUFFER             26
#define PMIX_BYTE_OBJECT        27
#define PMIX_KVAL               28
#define PMIX_MODEX              29
#define PMIX_PERSIST            30
#define PMIX_POINTER            31
#define PMIX_SCOPE              32
#define PMIX_DATA_RANGE         33
#define PMIX_COMMAND            34
#define PMIX_INFO_DIRECTIVES    35
#define PMIX_DATA_TYPE          36
#define PMIX_PROC_STATE         37
#define PMIX_PROC_INFO          38
#define PMIX_DATA_ARRAY         39
#define PMIX_PROC_RANK          40
#define PMIX_QUERY              41
#define PMIX_COMPRESSED_STRING  42  // string compressed with zlib
#define PMIX_ALLOC_DIRECTIVE    43
/**** DEPRECATED ****/
#define PMIX_INFO_ARRAY         44
/********************/

/* define a boundary for implementers so they can add their own data types */
#define PMIX_DATA_TYPE_MAX     500
\end{codepar}
\cspecificend


%%%%%%%%%%%
\subsection{\code{pmix_scope_t}}
\declarestruct{pmix_scope_t}

The \refstruct{pmix_scope_t} structure is an integer type for defining the scope for data ``put'' by PMIx
The table below defines the possible values for \refstruct{pmix_scope_t}.

\cspecificstart
\begin{codepar}
/*
 * PMI_LOCAL - the data is intended only for other application
 *             processes on the same node. Data marked in this way
 *             will not be included in data packages sent to remote requestors
 * PMI_REMOTE - the data is intended solely for applications processes on
 *              remote nodes. Data marked in this way will not be shared with
 *              other processes on the same node
 * PMI_GLOBAL - the data is to be shared with all other requesting processes,
 *              regardless of location
 */
#define PMIX_SCOPE_UNDEF    0
#define PMIX_LOCAL          1   // share to procs also on this node
#define PMIX_REMOTE         2   // share with procs not on this node
#define PMIX_GLOBAL         3   // share with all procs (local + remote)
#define PMIX_INTERNAL       4   // store data in the internal tables
\end{codepar}
\cspecificend

Scope values are defined as:
\begin{constantdesc}
\declareconstitem{PMIX_LOCAL} limit access to this data to processes on the same node
\declareconstitem{PMIX_REMOTE} limit access to this data to processes on nodes other than this one
\declareconstitem{PMIX_GLOBAL} access permitted by all processes (local and remote)
\declareconstitem{PMIX_INTERNAL} data is for use solely within this process
\end{constantdesc}

Specific implementations may support different scope values, but all implementations must support at least \refconst{PMIX_GLOBAL}.



%%%%%%%%%%%
\subsection{\code{pmix_data_range_t}}
\declarestruct{pmix_data_range_t}

The \refstruct{pmix_data_range_t} structure is an integer type for defining a range for ``published'' data.
The table below defines the possible values for \refstruct{pmix_data_range_t}.

\cspecificstart
\begin{codepar}
//
#define PMIX_RANGE_UNDEF        0
#define PMIX_RANGE_RM           1   // data is intended for the host resource manager
#define PMIX_RANGE_LOCAL        2   // available on local node only
#define PMIX_RANGE_NAMESPACE    3   // data is available to procs in the same nspace only
#define PMIX_RANGE_SESSION      4   // data available to all procs in session
#define PMIX_RANGE_GLOBAL       5   // data available to all procs
#define PMIX_RANGE_CUSTOM       6   // range is specified in a pmix_info_t
#define PMIX_RANGE_PROC_LOCAL   7   // restrict range to the local proc
\end{codepar}
\cspecificend

%%%%%%%%%%%
\subsection{\code{pmix_persistence_t}}
\declarestruct{pmix_persistence_t}

The \refstruct{pmix_persistence_t} structure is an integer type for defining the policy for data published by clients.
The table below defines the possible values for \refstruct{pmix_persistence_t}.

\cspecificstart
\begin{codepar}
//
#define PMIX_PERSIST_INDEF          0   // retain until specifically deleted
#define PMIX_PERSIST_FIRST_READ     1   // delete upon first access
#define PMIX_PERSIST_PROC           2   // retain until publishing process terminates
#define PMIX_PERSIST_APP            3   // retain until application terminates
#define PMIX_PERSIST_SESSION        4   // retain until session/allocation terminates
\end{codepar}
\cspecificend


%%%%%%%%%%%
\subsection{\code{pmix_info_directives_t}}
\declarestruct{pmix_info_directives_t}

The \refstruct{pmix_info_directives_t} structure is an integer type for defining the behavior of command directives via \refstruct{pmix_info_t} arrays.
The table below defines the possible values for \refstruct{pmix_info_directives_t}.

\cspecificstart
\begin{codepar}
//
#define PMIX_INFO_REQD          0x0001
\end{codepar}
\cspecificend


%%%%%%%%%%%
\subsection{\code{pmix_alloc_directive_t}}
\declarestruct{pmix_alloc_directive_t}

The \refstruct{pmix_alloc_directive_t} structure is an integer type for defining the behavior of allocation requests.
The table below defines the possible values for \refstruct{pmix_alloc_directive_t}.

\cspecificstart
\begin{codepar}
//
#define PMIX_ALLOC_NEW          1  // new allocation is being requested. The resulting allocation will be
                                   // disjoint (i.e., not connected in a job sense) from the requesting allocation
#define PMIX_ALLOC_EXTEND       2  // extend the existing allocation, either in time or as additional resources
#define PMIX_ALLOC_RELEASE      3  // release part of the existing allocation. Attributes in the accompanying
                                   // pmix\_info\_t array may be used to specify permanent release of the
                                   // identified resources, or "lending" of those resources for some period
                                   // of time.
#define PMIX_ALLOC_REAQUIRE     4  // reacquire resources that were previously "lent" back to the scheduler

/* define a value boundary beyond which implementers are free
 * to define their own directive values */
#define PMIX_ALLOC_EXTERNAL     128
\end{codepar}
\cspecificend


%%%%%%%%%%%
\section{Data Packing/Unpacking}

\ldots

%%%%%%%%%%%
\subsection{Byte Object}
\declarestruct{pmix_byte_object_t}
\declarestruct{pmix_data_buffer_t}

The \refstruct{pmix_byte_object_t} structure is \ldots

\cspecificstart
\begin{codepar}
typedef struct pmix_byte_object {
    char *bytes;
    size_t size;
} pmix_byte_object_t;
#define PMIX_BYTE_OBJECT_DESTRUCT(m)
#define PMIX_BYTE_OBJECT_FREE(m, n)
\end{codepar}
\cspecificend

The \refstruct{pmix_data_buffer_t} structure is \ldots

\cspecificstart
\begin{codepar}
/****    PMIX DATA BUFFER    ****/
typedef struct pmix_data_buffer {
    /** Start of my memory */
    char *base_ptr;
    /** Where the next data will be packed to (within the allocated
        memory starting at base_ptr) */
    char *pack_ptr;
    /** Where the next data will be unpacked from (within the
        allocated memory starting as base_ptr) */
    char *unpack_ptr;
    /** Number of bytes allocated (starting at base_ptr) */
    size_t bytes_allocated;
    /** Number of bytes used by the buffer (i.e., amount of data --
        including overhead -- packed in the buffer) */
    size_t bytes_used;
} pmix_data_buffer_t;

#define PMIX_DATA_BUFFER_CREATE(m)
#define PMIX_DATA_BUFFER_RELEASE(m)
#define PMIX_DATA_BUFFER_CONSTRUCT(m)
#define PMIX_DATA_BUFFER_DESTRUCT(m)
\end{codepar}
\cspecificend


%%%%%%%%%%%
\section{Data Structures}

\ldots


%%%%%%%%%%%
\subsection{Process Structure}
\declarestruct{pmix_proc_t}

The \refstruct{pmix_proc_t} structure is \ldots

\cspecificstart
\begin{codepar}
typedef struct pmix_proc {
    char nspace[PMIX_MAX_NSLEN+1];
    pmix_rank_t rank;
} pmix_proc_t;
#define PMIX_PROC_CREATE(m, n)
#define PMIX_PROC_RELEASE(m)
#define PMIX_PROC_CONSTRUCT(m)
#define PMIX_PROC_DESTRUCT(m)
#define PMIX_PROC_FREE(m, n)
\end{codepar}
\cspecificend


%%%%%%%%%%%
\subsection{Process Info Structure}
\declarestruct{pmix_proc_info_t}

The \refstruct{pmix_proc_info_t} structure is \ldots

\cspecificstart
\begin{codepar}
typedef struct pmix_proc_info {
    pmix_proc_t proc;
    char *hostname;
    char *executable_name;
    pid_t pid;
    int exit_code;
    pmix_proc_state_t state;
} pmix_proc_info_t;
#define PMIX_PROC_INFO_CREATE(m, n)
#define PMIX_PROC_INFO_RELEASE(m)
#define PMIX_PROC_INFO_CONSTRUCT(m)
#define PMIX_PROC_INFO_DESTRUCT(m)
#define PMIX_PROC_INFO_FREE(m, n)
\end{codepar}
\cspecificend


%%%%%%%%%%%
\subsection{Data Array Structure}
\declarestruct{pmix_data_array}

The \refstruct{pmix_data_array} structure is \ldots

\cspecificstart
\begin{codepar}
typedef struct pmix_data_array {
    pmix_data_type_t type;
    size_t size;
    void *array;
} pmix_data_array_t;
\end{codepar}
\cspecificend


%%%%%%%%%%%
\subsection{Value Structure}
\declarestruct{pmix_value_t}

The \refstruct{pmix_value_t} structure is \ldots

\cspecificstart
\begin{codepar}
/* NOTE: operations can supply a collection of values under
 * a single key by passing a pmix_value_t containing an
 * array of type PMIX_INFO_ARRAY, with each array element
 * containing its own pmix_info_t object */

typedef struct pmix_value {
    pmix_data_type_t type;
    union {
        bool flag;
        uint8_t byte;
        char *string;
        size_t size;
        pid_t pid;
        int integer;
        int8_t int8;
        int16_t int16;
        int32_t int32;
        int64_t int64;
        unsigned int uint;
        uint8_t uint8;
        uint16_t uint16;
        uint32_t uint32;
        uint64_t uint64;
        float fval;
        double dval;
        struct timeval tv;
        time_t time;
        pmix_status_t status;
        pmix_rank_t rank;
        pmix_proc_t *proc;
        pmix_byte_object_t bo;
        pmix_persistence_t persist;
        pmix_scope_t scope;
        pmix_data_range_t range;
        pmix_proc_state_t state;
        pmix_proc_info_t *pinfo;
        pmix_data_array_t *darray;
        void *ptr;
        pmix_alloc_directive_t adir;
        /**** DEPRECATED ****/
        pmix_info_array_t *array;
        /********************/
    } data;
} pmix_value_t;
#define PMIX_VALUE_CREATE(m, n)
#define PMIX_VALUE_RELEASE(m)
#define PMIX_VALUE_CONSTRUCT(m)
#define PMIX_VALUE_DESTRUCT(m)
#define PMIX_VALUE_FREE(m, n)

/* expose some functions that are resolved in the
 * PMIx library, but part of a header that
 * includes internal functions - we don't
 * want to expose the entire header here. For
 * consistency, we provide macro versions as well
 */
void pmix_value_load(pmix_value_t *v, const void *data, pmix_data_type_t type);
#define PMIX_VALUE_LOAD(v, d, t) \
    pmix_value_load((v), (d), (t))

pmix_status_t pmix_value_xfer(pmix_value_t *kv, pmix_value_t *src);
#define PMIX_VALUE_XFER(r, v, s)                                \

pmix_status_t pmix_argv_append_nosize(char ***argv, const char *arg);
#define PMIX_ARGV_APPEND(r, a, b) \
    (r) = pmix_argv_append_nosize(&(a), (b))

pmix_status_t pmix_setenv(const char *name, const char *value,
                          bool overwrite, char ***env);
#define PMIX_SETENV(r, a, b, c) \
    (r) = pmix_setenv((a), (b), true, (c))
\end{codepar}
\cspecificend


%%%%%%%%%%%
\subsection{Info and Info Array Structures}
\declarestruct{pmix_info_t}
\declarestruct{pmix_info_array}

The \refstruct{pmix_info_t} structure is \ldots

The \refstruct{pmix_info_array} structure is \ldots

\cspecificstart
\begin{codepar}
struct pmix_info_t {
    char key[PMIX_MAX_KEYLEN+1];    // ensure room for the NULL terminator
    pmix_info_directives_t flags;   // bit-mask of flags
    pmix_value_t value;
};

typedef struct pmix_info_array {
    size_t size;
    pmix_info_t *array;
} pmix_info_array_t;

/* utility macros for working with pmix_info_t structs */
#define PMIX_INFO_CREATE(m, n)
#define PMIX_INFO_CONSTRUCT(m)
#define PMIX_INFO_DESTRUCT(m)
#define PMIX_INFO_FREE(m, n)
#define PMIX_INFO_LOAD(m, k, v, t)
#define PMIX_INFO_XFER(d, s)
#define PMIX_INFO_REQUIRED(m)
#define PMIX_INFO_OPTIONAL(m)
#define PMIX_INFO_UNLOAD(r, v, l)
#define PMIX_INFO_TRUE(m)
\end{codepar}
\cspecificend


%%%%%%%%%%%
\subsection{Lookup Return Structure}
\declarestruct{pmix_pdata_t}

The \refstruct{pmix_pdata_t} structure is \ldots

\cspecificstart
\begin{codepar}
typedef struct pmix_pdata {
    pmix_proc_t proc;
    char key[PMIX_MAX_KEYLEN+1];  // ensure room for the NULL terminator
    pmix_value_t value;
} pmix_pdata_t;

#define PMIX_PDATA_CREATE(m, n)
#define PMIX_PDATA_RELEASE(m)
#define PMIX_PDATA_CONSTRUCT(m)
#define PMIX_PDATA_DESTRUCT(m)
#define PMIX_PDATA_FREE(m, n)
#define PMIX_PDATA_LOAD(m, p, k, v, t)
#define PMIX_PDATA_XFER(d, s)
\end{codepar}
\cspecificend


%%%%%%%%%%%
\subsection{App Structure}
\declarestruct{pmix_app_t}

The \refstruct{pmix_app_t} structure is \ldots

\cspecificstart
\begin{codepar}
typedef struct pmix_app {
    char *cmd;
    char **argv;
    char **env;
    char *cwd;
    int maxprocs;
    pmix_info_t *info;
    size_t ninfo;
} pmix_app_t;

/* utility macros for working with pmix_app_t structs */
#define PMIX_APP_CREATE(m, n)
#define PMIX_APP_RELEASE(m)
#define PMIX_APP_CONSTRUCT(m)
#define PMIX_APP_DESTRUCT(m)
#define PMIX_APP_FREE(m, n)
\end{codepar}
\cspecificend


%%%%%%%%%%%
\subsection{Query Structure}
\declarestruct{pmix_query_t}

The \refstruct{pmix_query_t} structure is \ldots

\cspecificstart
\begin{codepar}
typedef struct pmix_query {
    char **keys;
    pmix_info_t *qualifiers;
    size_t nqual;
} pmix_query_t;

/* utility macros for working with pmix_query_t structs */
#define PMIX_QUERY_CREATE(m, n)
#define PMIX_QUERY_RELEASE(m)
#define PMIX_QUERY_CONSTRUCT(m)
#define PMIX_QUERY_DESTRUCT(m)
#define PMIX_QUERY_FREE(m, n)
\end{codepar}
\cspecificend


%%%%%%%%%%%
\subsection{Modex Structure}
\declarestruct{pmix_modex_data_t}

The \refstruct{pmix_modex_data_t} structure is \ldots

\cspecificstart
\begin{codepar}
typedef struct pmix_modex_data {
    char nspace[PMIX_MAX_NSLEN+1];
    int rank;
    uint8_t *blob;
    size_t size;
} pmix_modex_data_t;

/* utility macros for working with pmix_modex_t structs */
#define PMIX_MODEX_CREATE(m, n)
#define PMIX_MODEX_RELEASE(m)
#define PMIX_MODEX_CONSTRUCT(m)
#define PMIX_MODEX_DESTRUCT(m)
#define PMIX_MODEX_FREE(m, n)
\end{codepar}
\cspecificend


%%%%%%%%%%%
\section{Callback Functions}

\ldots

%%%%%%%%%%%
\subsection{Release Callback Function}
\declareapi{pmix_release_cbfunc_t}

The \refapi{pmix_release_cbfunc_t} \ldots

\cspecificstart
\begin{codepar}
typedef void (*pmix_release_cbfunc_t)(void *cbdata)
\end{codepar}
\cspecificend


%%%%%%%%%%%
\subsection{Modex Callback Function}
\declareapi{pmix_modex_cbfunc_t}

The \refapi{pmix_modex_cbfunc_t} \ldots

\cspecificstart
\begin{codepar}
/* define a callback function that is solely used by servers, and
 * not clients, to return modex data in response to "fence" and "get"
 * operations. The returned blob contains the data collected from each
 * server participating in the operation.
 *
 * As the data is "owned" by the host server, provide a secondary
 * callback function to notify the host server that we are done
 * with the data so it can be released */
typedef void (*pmix_modex_cbfunc_t)(pmix_status_t status,
                                    const char *data, size_t ndata,
                                    void *cbdata,
                                    pmix_release_cbfunc_t release_fn,
                                    void *release_cbdata)

\end{codepar}
\cspecificend

%%%%
\descr

\ldots

%%%%%%%%%%%
\subsection{Spawn Callback Function}
\declareapi{pmix_spawn_cbfunc_t}

The \refapi{pmix_spawn_cbfunc_t} \ldots

\cspecificstart
\begin{codepar}
/* define a callback function for calls to PMIx_Spawn_nb - the function
 * will be called upon completion of the spawn command. The status
 * will indicate whether or not the spawn succeeded. The nspace
 * of the spawned processes will be returned, along with any provided
 * callback data. Note that the returned nspace value will be
 * released by the library upon return from the callback function, so
 * the receiver must copy it if it needs to be retained */
typedef void (*pmix_spawn_cbfunc_t)(pmix_status_t status,
                                    char nspace[], void *cbdata);
\end{codepar}
\cspecificend


%%%%
\descr

The callback will be executed upon launch of the specified applications, or upon failure to launch any of them.

The \refarg{status} of the callback will indicate whether or not the spawn succeeded.
The \refarg{nspace} of the spawned processes will be returned, along with any provided callback data.
Note that the returned \refarg{nspace} value will be released by the library upon return from the callback function, so the receiver must copy it if it needs to be retained.


%%%%%%%%%%%
\subsection{Op Callback Function}
\declareapi{pmix_op_cbfunc_t}

The \refapi{pmix_op_cbfunc_t} \ldots

\cspecificstart
\begin{codepar}
/* define a callback for common operations that simply return
 * a status. Examples include the non-blocking versions of
 * Fence, Connect, and Disconnect */
typedef void (*pmix_op_cbfunc_t)(pmix_status_t status, void *cbdata);
\end{codepar}
\cspecificend

%%%%
\descr

\ldots


%%%%%%%%%%%
\subsection{Lookup Callback Function}
\declareapi{pmix_lookup_cbfunc_t}

The \refapi{pmix_lookup_cbfunc_t} \ldots

\cspecificstart
\begin{codepar}
/* define a callback function for calls to PMIx_Lookup_nb - the
 * function will be called upon completion of the command with the
 * status indicating the success of failure of the request. Any
 * retrieved data will be returned in an array of pmix_pdata_t structs.
 * The nspace/rank of the process that provided each data element is
 * also returned.
 *
 * Note that these structures will be released upon return from
 * the callback function, so the receiver must copy/protect the
 * data prior to returning if it needs to be retained */

typedef void (*pmix_lookup_cbfunc_t)(pmix_status_t status,
                                     pmix_pdata_t data[], size_t ndata,
                                     void *cbdata);
\end{codepar}
\cspecificend

%%%%
\descr

\ldots




%%%%%%%%%%%
\subsection{Value Callback Function}
\declareapi{pmix_value_cbfunc_t}

The \refapi{pmix_value_cbfunc_t} \ldots

\cspecificstart
\begin{codepar}
/* define a callback function for calls to PMIx_Get_nb. The status
 * indicates if the requested data was found or not - a pointer to the
 * pmix_value_t structure containing the found data is returned. The
 * pointer will be NULL if the requested data was not found. */
typedef void (*pmix_value_cbfunc_t)(pmix_status_t status,
                                    pmix_value_t *kv, void *cbdata);
\end{codepar}
\cspecificend

%%%%
\descr

\ldots


%%%%%%%%%%%
\subsection{Info Function}
\declareapi{pmix_info_cbfunc_t}

The \refapi{pmix_info_cbfunc_t} \ldots

\cspecificstart
\begin{codepar}
/* define a callback function for calls to PMIx_Query. The status
 * indicates if requested data was found or not - an array of
 * pmix_info_t will contain the key/value pairs. */
typedef void (*pmix_info_cbfunc_t)(pmix_status_t status,
                                   pmix_info_t *info, size_t ninfo,
                                   void *cbdata,
                                   pmix_release_cbfunc_t release_fn,
                                   void *release_cbdata);
\end{codepar}
\cspecificend

%%%%
\descr

\ldots





%%%%%%%%%%%
\section{Other Support Functions}

\ldots

%%%%%%%%%%%
\subsection{Unsorted Function}

\cspecificstart
\begin{codepar}
/* Provide a string representation for several types of value. Note
 * that the provided string is statically defined and must NOT be
 * free'd. Supported value types:
 *
 * - pmix_status_t (PMIX_STATUS)
 * - pmix_scope_t   (PMIX_SCOPE)
 * - pmix_persistence_t  (PMIX_PERSIST)
 * - pmix_data_range_t   (PMIX_DATA_RANGE)
 * - pmix_info_directives_t   (PMIX_INFO_DIRECTIVES)
 * - pmix_data_type_t   (PMIX_DATA_TYPE)
 * - pmix_alloc_directive_t  (PMIX_ALLOC_DIRECTIVE)
 */
PMIX_EXPORT const char* PMIx_Error_string(pmix_status_t status);
PMIX_EXPORT const char* PMIx_Proc_state_string(pmix_proc_state_t state);
PMIX_EXPORT const char* PMIx_Scope_string(pmix_scope_t scope);
PMIX_EXPORT const char* PMIx_Persistence_string(pmix_persistence_t persist);
PMIX_EXPORT const char* PMIx_Data_range_string(pmix_data_range_t range);
PMIX_EXPORT const char* PMIx_Info_directives_string(pmix_info_directives_t directives);
PMIX_EXPORT const char* PMIx_Data_type_string(pmix_data_type_t type);
PMIX_EXPORT const char* PMIx_Alloc_directive_string(pmix_alloc_directive_t directive);
\end{codepar}
\cspecificend






%%%%%%%%%%%
\subsection{Key/Value Pair Management}


\cspecificstart
\begin{codepar}
/* Key-Value pair management macros */
// TODO: add all possible types/fields here.

#define PMIX_VAL_FIELD_int(x)       ((x)->data.integer)
#define PMIX_VAL_FIELD_uint32_t(x)  ((x)->data.uint32)
#define PMIX_VAL_FIELD_uint16_t(x)  ((x)->data.uint16)
#define PMIX_VAL_FIELD_string(x)    ((x)->data.string)
#define PMIX_VAL_FIELD_float(x)     ((x)->data.fval)
#define PMIX_VAL_FIELD_byte(x)      ((x)->data.byte)
#define PMIX_VAL_FIELD_flag(x)      ((x)->data.flag)

#define PMIX_VAL_TYPE_int      PMIX_INT
#define PMIX_VAL_TYPE_uint32_t PMIX_UINT32
#define PMIX_VAL_TYPE_uint16_t PMIX_UINT16
#define PMIX_VAL_TYPE_string   PMIX_STRING
#define PMIX_VAL_TYPE_float    PMIX_FLOAT
#define PMIX_VAL_TYPE_byte     PMIX_BYTE
#define PMIX_VAL_TYPE_flag     PMIX_BOOL
\end{codepar}
\cspecificend


\cspecificstart
\begin{codepar}

#define PMIX_VAL_set_assign(_v, _field, _val )
#define PMIX_VAL_set_strdup(_v, _field, _val )

#define PMIX_VAL_SET_int        PMIX_VAL_set_assign
#define PMIX_VAL_SET_uint32_t   PMIX_VAL_set_assign
#define PMIX_VAL_SET_uint16_t   PMIX_VAL_set_assign
#define PMIX_VAL_SET_string     PMIX_VAL_set_strdup
#define PMIX_VAL_SET_float      PMIX_VAL_set_assign
#define PMIX_VAL_SET_byte       PMIX_VAL_set_assign
#define PMIX_VAL_SET_flag       PMIX_VAL_set_assign

#define PMIX_VAL_SET(_v, _field, _val )
\end{codepar}
\cspecificend


\cspecificstart
\begin{codepar}

#define PMIX_VAL_cmp_val(_val1, _val2)      ((_val1) != (_val2))
#define PMIX_VAL_cmp_float(_val1, _val2)    (((_val1)>(_val2))?(((_val1)-(_val2))>0.000001):(((_val2)-(_val1))>0.000001))
#define PMIX_VAL_cmp_ptr(_val1, _val2)      strncmp(_val1, _val2, strlen(_val1)+1)

#define PMIX_VAL_CMP_int        PMIX_VAL_cmp_val
#define PMIX_VAL_CMP_uint32_t   PMIX_VAL_cmp_val
#define PMIX_VAL_CMP_uint16_t   PMIX_VAL_cmp_val
#define PMIX_VAL_CMP_float      PMIX_VAL_cmp_float
#define PMIX_VAL_CMP_string     PMIX_VAL_cmp_ptr
#define PMIX_VAL_CMP_byte       PMIX_VAL_cmp_val
#define PMIX_VAL_CMP_flag       PMIX_VAL_cmp_val
\end{codepar}
\cspecificend


\cspecificstart
\begin{codepar}

#define PMIX_VAL_ASSIGN(_v, _field, _val) \
#define PMIX_VAL_CMP(_field, _val1, _val2) \
#define PMIX_VAL_FREE(_v) \
\end{codepar}
\cspecificend


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
